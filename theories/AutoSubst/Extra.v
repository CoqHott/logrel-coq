(** * LogRel.AutoSubst.Extra: extra content to better handle the boilerplate generated by AutoSubst. *)

(** This is the only file in the AutoSubst submodule that is not automatically generated. *)
From smpl Require Import Smpl.
From Coq Require Import ssrbool List.
From LogRel.AutoSubst Require Import core unscoped Ast.
From LogRel Require Import Utils BasicAst.

(* Export UnscopedNotations.
#[global] Open Scope subst_scope. *)

Declare Scope asubst_scope.
Delimit Scope asubst_scope with asub.

Arguments funcomp {X Y Z}%type_scope (g f)%function_scope.

Notation "f >> g" := (funcomp g f) (at level 50) : function_scope.

Notation "s .: sigma" := (scons s sigma) (at level 55, sigma at next level, right associativity) : asubst_scope.

Notation "s ⟨ xi1 ⟩" := (ren1 xi1 s) (at level 7, left associativity, format "s ⟨ xi1 ⟩") : asubst_scope.
(* Notation "⟨ xi ⟩" := (ren1 xi) (at level 1, left associativity, format "⟨ xi ⟩") : function_scope. *)

Notation "s [ sigma ]" := (subst1 sigma s) (at level 7, left associativity, format "s '/' [ sigma ]") : asubst_scope.

Notation "s [ t ]⇑" := (subst_term (scons t (shift >> tRel)) s) (at level 7, left associativity, format "s '/' [ t ]⇑") : asubst_scope.

Notation "s '..'" := (scons s ids) (at level 1, format "s ..") : asubst_scope.

Notation "↑" := (shift) : asubst_scope.

#[global] Open Scope asubst_scope.

Notation U := (tSort set).
Notation "'eta_expand' f" := (tApp f⟨↑⟩ (tRel 0)) (at level 40, only parsing).

#[global] Instance Ren1_subst {Y Z : Type} `{Ren1 (nat -> nat) Y Z} :
  (Ren1 (nat -> nat) (nat -> Y) (nat -> Z)) :=
  fun ρ σ i => (σ i)⟨ρ⟩.
    
Ltac fold_autosubst :=
    fold ren_term ;
    fold subst_term.

Smpl Add fold_autosubst : refold.

Ltac change_autosubst :=
    change ren_term with (@ren1 _ _ _ Ren_term) in * ;
    change subst_term with (@subst1 _ _ _ Subst_term) in *;
    change (fun i => (?σ i)⟨?ρ⟩) with (@ren1 _ _ _ Ren1_subst ρ σ) in *.

Smpl Add 50 change_autosubst : refold.

Arguments ren1 {_ _ _}%type_scope {Ren1} _ !_/.
(* Ideally, we'd like Ren_term to not be there, and ren_term to be directly the Ren1 instance… *)
Arguments Ren_term _ _ /.
Arguments Ren1_subst {_ _ _} _ _/.

Notation arr A B := (tProd A B⟨↑⟩).
Notation comp A f g := (tLambda A (tApp f⟨↑⟩ (tApp g⟨↑⟩ (tRel 0)))).
Notation idterm A  := (tLambda A (tRel 0)).

Lemma arr_ren1 {A B} : forall ρ, (arr A B)⟨ρ⟩ = arr A⟨ρ⟩ B⟨ρ⟩.
Proof.
  now asimpl.
Qed.

Lemma subst_arr A B σ : (arr A B)[σ] = arr (subst_term σ A) (subst_term σ B).
Proof. now asimpl. Qed.

Definition elimSuccHypTy P :=
  tProd tNat (arr P P[tSucc (tRel 0)]⇑).

(*
  Γ |- A
  Γ , x : list A |- P

  Γ, x : A |- list A⟨↑⟩

  Γ, x : A |- <shift> : Γ
  Γ, x : A, y : list A⟨↑⟩ |- <up_ren shift> : Γ, x : list A
  Γ, x : A, y : list A⟨↑⟩ |- P<up_ren shift>


  Γ, x : A, y : list A⟨↑⟩ |- σ := ↑ >> ↑ >> tRel : Γ
  Γ, x : A, y : list A⟨↑⟩ |- tCons A⟨↑⟩⟨↑⟩ (tRel 1) (tRel 0) : list A[σ]
  Γ, x : A, y : list A⟨↑⟩ |- P[tCons A⟨↑⟩⟨↑⟩ (tRel 1) (tRel 0) .: σ]
  


  Γ, x : A, y : list A⟨↑⟩ |- P<up_ren shift> -> P[tCons A⟨↑⟩⟨↑⟩ (tRel 1) (tRel 0).: σ]
  Γ, x : A |- Π (list A⟨↑⟩) (P<up_ren shift> -> P[tCons A⟨↑⟩⟨↑⟩ (tRel 1) (tRel 0).: σ])
  Γ, x : A |- Π (list A⟨↑⟩) (P<up_ren shift> -> P[tCons A⟨↑⟩⟨↑⟩ (tRel 1) (tRel 0).: σ])
  Γ |- Π A Π (list A⟨↑⟩) (P<up_ren shift> -> P[tCons A⟨↑⟩⟨↑⟩ (tRel 1) (tRel 0).: σ])

  Γ |- elimConsHypTy A P
*)

Definition elimConsHypTy A P :=
  tProd A (tProd (tList A⟨↑⟩) (arr P⟨up_ren ↑⟩ P[tCons A⟨↑⟩⟨↑⟩ (tRel 1) (tRel 0) .: ↑ >> ↑ >> tRel])).

Fixpoint tApps (fn : list term) (t : term) :=
  match fn with
  | nil => t
  | f :: fn' => tApp f (tApps fn' t)
  end.

Definition eta_expands (fn : list term) :=
  (tApps (list_map (fun f => f⟨↑⟩) fn) (tRel 0)).

Definition comps (A : term) (fn : list term) :=
  tLambda A (eta_expands fn).

(** Flattening of map on lists; used in AlgorithmicTyping and Functions *)

Module Map.
  (** Triple of terms collecting the data of accumulated maps 
      The record needs to be negative so that we can use it in the 
      rule neuMapCompact *)
  #[projections(primitive)]
  Record data : Set := 
    mk { srcTy : term ; tgtTy : term ; fn : term ; lst : term }.

  (* for n a whne_list (in context Γ), 
     returns a pair (h, r) such that
     Γ, x : A ⊢ h : B,  Γ ⊢ r : list A and n ~ map (λ x. h) r*)

  Definition eta_id T n : data := {| srcTy := T ; tgtTy := T ; fn := tRel 0 ; lst := n |}.

  Definition eta T n : data :=
    match n with
    | tMap A B f l => {| srcTy := A ; tgtTy := B ; fn := eta_expand f ; lst := l |}
    | u => eta_id T u
    end.

  Lemma eta_eq_fn T T' n :
    (eta T n).(fn) = (eta T' n).(fn).
  Proof.
    destruct n ; cbn ; eauto.
  Qed.

  Lemma eta_eq_lst T T' n :
    (eta T n).(lst) = (eta T' n).(lst).
  Proof.
    destruct n ; cbn ; eauto.
  Qed.
  
  Definition is_map t :=
    match t with
    | tMap _ _ _ _ => true
    | _ => false
    end.
  
  Inductive view : term -> Type :=
    | IsMap {A B f l} : view (tMap A B f l)
    | IsNotMap {u} : ~~ is_map u -> view u.

  Definition into_view (t : term) : view t.
  Proof. destruct t; now econstructor. Defined.

  Lemma is_map_eta t :
    ~~ is_map t ->
    forall A, eta A t = eta_id A t.
  Proof.
    destruct t ; cbn ; try reflexivity.
    now congruence.
  Qed.

End Map.